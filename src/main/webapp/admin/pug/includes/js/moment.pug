| //! moment.js
| //! version : 2.10.6
| //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
| //! license : MIT
| //! momentjs.com
| (function (global, factory) {
| typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
| typeof define === 'function' && define.amd ? define(factory) :
| global.moment = factory()
| }(this, function () { 'use strict';
| var hookCallback;
| function utils_hooks__hooks () {
| return hookCallback.apply(null, arguments);
| }
| // This is done to register the method called with moment()
| // without creating circular dependencies.
| function setHookCallback (callback) {
| hookCallback = callback;
| }
| function isArray(input) {
| return Object.prototype.toString.call(input) === '[object Array]';
| }
| function isDate(input) {
| return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
| }
| function map(arr, fn) {
| var res = [], i;
| for (i = 0; i < arr.length; ++i) {
| res.push(fn(arr[i], i));
| }
| return res;
| }
| function hasOwnProp(a, b) {
| return Object.prototype.hasOwnProperty.call(a, b);
| }
| function extend(a, b) {
| for (var i in b) {
| if (hasOwnProp(b, i)) {
| a[i] = b[i];
| }
| }
| if (hasOwnProp(b, 'toString')) {
| a.toString = b.toString;
| }
| if (hasOwnProp(b, 'valueOf')) {
| a.valueOf = b.valueOf;
| }
| return a;
| }
| function create_utc__createUTC (input, format, locale, strict) {
| return createLocalOrUTC(input, format, locale, strict, true).utc();
| }
| function defaultParsingFlags() {
| // We need to deep clone this object.
| return {
| empty           : false,
| unusedTokens    : [],
| unusedInput     : [],
| overflow        : -2,
| charsLeftOver   : 0,
| nullInput       : false,
| invalidMonth    : null,
| invalidFormat   : false,
| userInvalidated : false,
| iso             : false
| };
| }
| function getParsingFlags(m) {
| if (m._pf == null) {
| m._pf = defaultParsingFlags();
| }
| return m._pf;
| }
| function valid__isValid(m) {
| if (m._isValid == null) {
| var flags = getParsingFlags(m);
| m._isValid = !isNaN(m._d.getTime()) &&
| flags.overflow < 0 &&
| !flags.empty &&
| !flags.invalidMonth &&
| !flags.invalidWeekday &&
| !flags.nullInput &&
| !flags.invalidFormat &&
| !flags.userInvalidated;
| if (m._strict) {
| m._isValid = m._isValid &&
| flags.charsLeftOver === 0 &&
| flags.unusedTokens.length === 0 &&
| flags.bigHour === undefined;
| }
| }
| return m._isValid;
| }
| function valid__createInvalid (flags) {
| var m = create_utc__createUTC(NaN);
| if (flags != null) {
| extend(getParsingFlags(m), flags);
| }
| else {
| getParsingFlags(m).userInvalidated = true;
| }
| return m;
| }
| var momentProperties = utils_hooks__hooks.momentProperties = [];
| function copyConfig(to, from) {
| var i, prop, val;
| if (typeof from._isAMomentObject !== 'undefined') {
| to._isAMomentObject = from._isAMomentObject;
| }
| if (typeof from._i !== 'undefined') {
| to._i = from._i;
| }
| if (typeof from._f !== 'undefined') {
| to._f = from._f;
| }
| if (typeof from._l !== 'undefined') {
| to._l = from._l;
| }
| if (typeof from._strict !== 'undefined') {
| to._strict = from._strict;
| }
| if (typeof from._tzm !== 'undefined') {
| to._tzm = from._tzm;
| }
| if (typeof from._isUTC !== 'undefined') {
| to._isUTC = from._isUTC;
| }
| if (typeof from._offset !== 'undefined') {
| to._offset = from._offset;
| }
| if (typeof from._pf !== 'undefined') {
| to._pf = getParsingFlags(from);
| }
| if (typeof from._locale !== 'undefined') {
| to._locale = from._locale;
| }
| if (momentProperties.length > 0) {
| for (i in momentProperties) {
| prop = momentProperties[i];
| val = from[prop];
| if (typeof val !== 'undefined') {
| to[prop] = val;
| }
| }
| }
| return to;
| }
| var updateInProgress = false;
| // Moment prototype object
| function Moment(config) {
| copyConfig(this, config);
| this._d = new Date(config._d != null ? config._d.getTime() : NaN);
| // Prevent infinite loop in case updateOffset creates new moment
| // objects.
| if (updateInProgress === false) {
| updateInProgress = true;
| utils_hooks__hooks.updateOffset(this);
| updateInProgress = false;
| }
| }
| function isMoment (obj) {
| return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
| }
| function absFloor (number) {
| if (number < 0) {
| return Math.ceil(number);
| } else {
| return Math.floor(number);
| }
| }
| function toInt(argumentForCoercion) {
| var coercedNumber = +argumentForCoercion,
| value = 0;
| if (coercedNumber !== 0 && isFinite(coercedNumber)) {
| value = absFloor(coercedNumber);
| }
| return value;
| }
| function compareArrays(array1, array2, dontConvert) {
| var len = Math.min(array1.length, array2.length),
| lengthDiff = Math.abs(array1.length - array2.length),
| diffs = 0,
| i;
| for (i = 0; i < len; i++) {
| if ((dontConvert && array1[i] !== array2[i]) ||
| (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
| diffs++;
| }
| }
| return diffs + lengthDiff;
| }
| function Locale() {
| }
| var locales = {};
| var globalLocale;
| function normalizeLocale(key) {
| return key ? key.toLowerCase().replace('_', '-') : key;
| }
| // pick the locale from the array
| // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
| // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
| function chooseLocale(names) {
| var i = 0, j, next, locale, split;
| while (i < names.length) {
| split = normalizeLocale(names[i]).split('-');
| j = split.length;
| next = normalizeLocale(names[i + 1]);
| next = next ? next.split('-') : null;
| while (j > 0) {
| locale = loadLocale(split.slice(0, j).join('-'));
| if (locale) {
| return locale;
| }
| if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
| //the next array item is better than a shallower substring of this one
| break;
| }
| j--;
| }
| i++;
| }
| return null;
| }
| function loadLocale(name) {
| var oldLocale = null;
| // TODO: Find a better way to register and load all the locales in Node
| if (!locales[name] && typeof module !== 'undefined' &&
| module && module.exports) {
| try {
| oldLocale = globalLocale._abbr;
| require('./locale/' + name);
| // because defineLocale currently also sets the global locale, we
| // want to undo that for lazy loaded locales
| locale_locales__getSetGlobalLocale(oldLocale);
| } catch (e) { }
| }
| return locales[name];
| }
| // This function will load locale and then set the global locale.  If
| // no arguments are passed in, it will simply return the current global
| // locale key.
| function locale_locales__getSetGlobalLocale (key, values) {
| var data;
| if (key) {
| if (typeof values === 'undefined') {
| data = locale_locales__getLocale(key);
| }
| else {
| data = defineLocale(key, values);
| }
| if (data) {
| // moment.duration._locale = moment._locale = data;
| globalLocale = data;
| }
| }
| return globalLocale._abbr;
| }
| function defineLocale (name, values) {
| if (values !== null) {
| values.abbr = name;
| locales[name] = locales[name] || new Locale();
| locales[name].set(values);
| // backwards compat for now: also set the locale
| locale_locales__getSetGlobalLocale(name);
| return locales[name];
| } else {
| // useful for testing
| delete locales[name];
| return null;
| }
| }
| // returns locale data
| function locale_locales__getLocale (key) {
| var locale;
| if (key && key._locale && key._locale._abbr) {
| key = key._locale._abbr;
| }
| if (!key) {
| return globalLocale;
| }
| if (!isArray(key)) {
| //short-circuit everything else
| locale = loadLocale(key);
| if (locale) {
| return locale;
| }
| key = [key];
| }
| return chooseLocale(key);
| }
| var aliases = {};
| function addUnitAlias (unit, shorthand) {
| var lowerCase = unit.toLowerCase();
| aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
| }
| function normalizeUnits(units) {
| return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
| }
| function normalizeObjectUnits(inputObject) {
| var normalizedInput = {},
| normalizedProp,
| prop;
| for (prop in inputObject) {
| if (hasOwnProp(inputObject, prop)) {
| normalizedProp = normalizeUnits(prop);
| if (normalizedProp) {
| normalizedInput[normalizedProp] = inputObject[prop];
| }
| }
| }
| return normalizedInput;
| }
| function makeGetSet (unit, keepTime) {
| return function (value) {
| if (value != null) {
| get_set__set(this, unit, value);
| utils_hooks__hooks.updateOffset(this, keepTime);
| return this;
| } else {
| return get_set__get(this, unit);
| }
| };
| }
| function get_set__get (mom, unit) {
| return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
| }
| function get_set__set (mom, unit, value) {
| return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
| }
| // MOMENTS
| function getSet (units, value) {
| var unit;
| if (typeof units === 'object') {
| for (unit in units) {
| this.set(unit, units[unit]);
| }
| } else {
| units = normalizeUnits(units);
| if (typeof this[units] === 'function') {
| return this[units](value);
| }
| }
| return this;
| }
| function zeroFill(number, targetLength, forceSign) {
| var absNumber = '' + Math.abs(number),
| zerosToFill = targetLength - absNumber.length,
| sign = number >= 0;
| return (sign ? (forceSign ? '+' : '') : '-') +
| Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
| }
| var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
| var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
| var formatFunctions = {};
| var formatTokenFunctions = {};
| // token:    'M'
| // padded:   ['MM', 2]
| // ordinal:  'Mo'
| // callback: function () { this.month() + 1 }
| function addFormatToken (token, padded, ordinal, callback) {
| var func = callback;
| if (typeof callback === 'string') {
| func = function () {
| return this[callback]();
| };
| }
| if (token) {
| formatTokenFunctions[token] = func;
| }
| if (padded) {
| formatTokenFunctions[padded[0]] = function () {
| return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
| };
| }
| if (ordinal) {
| formatTokenFunctions[ordinal] = function () {
| return this.localeData().ordinal(func.apply(this, arguments), token);
| };
| }
| }
| function removeFormattingTokens(input) {
| if (input.match(/\[[\s\S]/)) {
| return input.replace(/^\[|\]$/g, '');
| }
| return input.replace(/\\/g, '');
| }
| function makeFormatFunction(format) {
| var array = format.match(formattingTokens), i, length;
| for (i = 0, length = array.length; i < length; i++) {
| if (formatTokenFunctions[array[i]]) {
| array[i] = formatTokenFunctions[array[i]];
| } else {
| array[i] = removeFormattingTokens(array[i]);
| }
| }
| return function (mom) {
| var output = '';
| for (i = 0; i < length; i++) {
| output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
| }
| return output;
| };
| }
| // format date using native date object
| function formatMoment(m, format) {
| if (!m.isValid()) {
| return m.localeData().invalidDate();
| }
| format = expandFormat(format, m.localeData());
| formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
| return formatFunctions[format](m);
| }
| function expandFormat(format, locale) {
| var i = 5;
| function replaceLongDateFormatTokens(input) {
| return locale.longDateFormat(input) || input;
| }
| localFormattingTokens.lastIndex = 0;
| while (i >= 0 && localFormattingTokens.test(format)) {
| format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
| localFormattingTokens.lastIndex = 0;
| i -= 1;
| }
| return format;
| }
| var match1         = /\d/;            //       0 - 9
| var match2         = /\d\d/;          //      00 - 99
| var match3         = /\d{3}/;         //     000 - 999
| var match4         = /\d{4}/;         //    0000 - 9999
| var match6         = /[+-]?\d{6}/;    // -999999 - 999999
| var match1to2      = /\d\d?/;         //       0 - 99
| var match1to3      = /\d{1,3}/;       //       0 - 999
| var match1to4      = /\d{1,4}/;       //       0 - 9999
| var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
| var matchUnsigned  = /\d+/;           //       0 - inf
| var matchSigned    = /[+-]?\d+/;      //    -inf - inf
| var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
| var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
| // any word (or two) characters or numbers including two/three word month in arabic.
| var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
| var regexes = {};
| function isFunction (sth) {
| // https://github.com/moment/moment/issues/2325
| return typeof sth === 'function' &&
| Object.prototype.toString.call(sth) === '[object Function]';
| }
| function addRegexToken (token, regex, strictRegex) {
| regexes[token] = isFunction(regex) ? regex : function (isStrict) {
| return (isStrict && strictRegex) ? strictRegex : regex;
| };
| }
| function getParseRegexForToken (token, config) {
| if (!hasOwnProp(regexes, token)) {
| return new RegExp(unescapeFormat(token));
| }
| return regexes[token](config._strict, config._locale);
| }
| // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
| function unescapeFormat(s) {
| return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
| return p1 || p2 || p3 || p4;
| }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
| }
| var tokens = {};
| function addParseToken (token, callback) {
| var i, func = callback;
| if (typeof token === 'string') {
| token = [token];
| }
| if (typeof callback === 'number') {
| func = function (input, array) {
| array[callback] = toInt(input);
| };
| }
| for (i = 0; i < token.length; i++) {
| tokens[token[i]] = func;
| }
| }
| function addWeekParseToken (token, callback) {
| addParseToken(token, function (input, array, config, token) {
| config._w = config._w || {};
| callback(input, config._w, config, token);
| });
| }
| function addTimeToArrayFromToken(token, input, config) {
| if (input != null && hasOwnProp(tokens, token)) {
| tokens[token](input, config._a, config, token);
| }
| }
| var YEAR = 0;
| var MONTH = 1;
| var DATE = 2;
| var HOUR = 3;
| var MINUTE = 4;
| var SECOND = 5;
| var MILLISECOND = 6;
| function daysInMonth(year, month) {
| return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
| }
| // FORMATTING
| addFormatToken('M', ['MM', 2], 'Mo', function () {
| return this.month() + 1;
| });
| addFormatToken('MMM', 0, 0, function (format) {
| return this.localeData().monthsShort(this, format);
| });
| addFormatToken('MMMM', 0, 0, function (format) {
| return this.localeData().months(this, format);
| });
| // ALIASES
| addUnitAlias('month', 'M');
| // PARSING
| addRegexToken('M',    match1to2);
| addRegexToken('MM',   match1to2, match2);
| addRegexToken('MMM',  matchWord);
| addRegexToken('MMMM', matchWord);
| addParseToken(['M', 'MM'], function (input, array) {
| array[MONTH] = toInt(input) - 1;
| });
| addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
| var month = config._locale.monthsParse(input, token, config._strict);
| // if we didn't find a month name, mark the date as invalid.
| if (month != null) {
| array[MONTH] = month;
| } else {
| getParsingFlags(config).invalidMonth = input;
| }
| });
| // LOCALES
| var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
| function localeMonths (m) {
| return this._months[m.month()];
| }
| var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
| function localeMonthsShort (m) {
| return this._monthsShort[m.month()];
| }
| function localeMonthsParse (monthName, format, strict) {
| var i, mom, regex;
| if (!this._monthsParse) {
| this._monthsParse = [];
| this._longMonthsParse = [];
| this._shortMonthsParse = [];
| }
| for (i = 0; i < 12; i++) {
| // make the regex if we don't have it already
| mom = create_utc__createUTC([2000, i]);
| if (strict && !this._longMonthsParse[i]) {
| this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
| this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
| }
| if (!strict && !this._monthsParse[i]) {
| regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
| this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
| }
| // test the regex
| if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
| return i;
| } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
| return i;
| } else if (!strict && this._monthsParse[i].test(monthName)) {
| return i;
| }
| }
| }
| // MOMENTS
| function setMonth (mom, value) {
| var dayOfMonth;
| // TODO: Move this out of here!
| if (typeof value === 'string') {
| value = mom.localeData().monthsParse(value);
| // TODO: Another silent failure?
| if (typeof value !== 'number') {
| return mom;
| }
| }
| dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
| mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
| return mom;
| }
| function getSetMonth (value) {
| if (value != null) {
| setMonth(this, value);
| utils_hooks__hooks.updateOffset(this, true);
| return this;
| } else {
| return get_set__get(this, 'Month');
| }
| }
| function getDaysInMonth () {
| return daysInMonth(this.year(), this.month());
| }
| function checkOverflow (m) {
| var overflow;
| var a = m._a;
| if (a && getParsingFlags(m).overflow === -2) {
| overflow =
| a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
| a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
| a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
| a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
| a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
| a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
| -1;
| if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
| overflow = DATE;
| }
| getParsingFlags(m).overflow = overflow;
| }
| return m;
| }
| function warn(msg) {
| if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
| console.warn('Deprecation warning: ' + msg);
| }
| }
| function deprecate(msg, fn) {
| var firstTime = true;
| return extend(function () {
| if (firstTime) {
| warn(msg + '\n' + (new Error()).stack);
| firstTime = false;
| }
| return fn.apply(this, arguments);
| }, fn);
| }
| var deprecations = {};
| function deprecateSimple(name, msg) {
| if (!deprecations[name]) {
| warn(msg);
| deprecations[name] = true;
| }
| }
| utils_hooks__hooks.suppressDeprecationWarnings = false;
| var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
| var isoDates = [
| ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
| ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
| ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
| ['GGGG-[W]WW', /\d{4}-W\d{2}/],
| ['YYYY-DDD', /\d{4}-\d{3}/]
| ];
| // iso time formats and regexes
| var isoTimes = [
| ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
| ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
| ['HH:mm', /(T| )\d\d:\d\d/],
| ['HH', /(T| )\d\d/]
| ];
| var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
| // date from iso format
| function configFromISO(config) {
| var i, l,
| string = config._i,
| match = from_string__isoRegex.exec(string);
| if (match) {
| getParsingFlags(config).iso = true;
| for (i = 0, l = isoDates.length; i < l; i++) {
| if (isoDates[i][1].exec(string)) {
| config._f = isoDates[i][0];
| break;
| }
| }
| for (i = 0, l = isoTimes.length; i < l; i++) {
| if (isoTimes[i][1].exec(string)) {
| // match[6] should be 'T' or space
| config._f += (match[6] || ' ') + isoTimes[i][0];
| break;
| }
| }
| if (string.match(matchOffset)) {
| config._f += 'Z';
| }
| configFromStringAndFormat(config);
| } else {
| config._isValid = false;
| }
| }
| // date from iso format or fallback
| function configFromString(config) {
| var matched = aspNetJsonRegex.exec(config._i);
| if (matched !== null) {
| config._d = new Date(+matched[1]);
| return;
| }
| configFromISO(config);
| if (config._isValid === false) {
| delete config._isValid;
| utils_hooks__hooks.createFromInputFallback(config);
| }
| }
| utils_hooks__hooks.createFromInputFallback = deprecate(
| 'moment construction falls back to js Date. This is ' +
| 'discouraged and will be removed in upcoming major ' +
| 'release. Please refer to ' +
| 'https://github.com/moment/moment/issues/1407 for more info.',
| function (config) {
| config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
| }
| );
| function createDate (y, m, d, h, M, s, ms) {
| //can't just apply() to create a date:
| //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
| var date = new Date(y, m, d, h, M, s, ms);
| //the date constructor doesn't accept years < 1970
| if (y < 1970) {
| date.setFullYear(y);
| }
| return date;
| }
| function createUTCDate (y) {
| var date = new Date(Date.UTC.apply(null, arguments));
| if (y < 1970) {
| date.setUTCFullYear(y);
| }
| return date;
| }
| addFormatToken(0, ['YY', 2], 0, function () {
| return this.year() % 100;
| });
| addFormatToken(0, ['YYYY',   4],       0, 'year');
| addFormatToken(0, ['YYYYY',  5],       0, 'year');
| addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
| // ALIASES
| addUnitAlias('year', 'y');
| // PARSING
| addRegexToken('Y',      matchSigned);
| addRegexToken('YY',     match1to2, match2);
| addRegexToken('YYYY',   match1to4, match4);
| addRegexToken('YYYYY',  match1to6, match6);
| addRegexToken('YYYYYY', match1to6, match6);
| addParseToken(['YYYYY', 'YYYYYY'], YEAR);
| addParseToken('YYYY', function (input, array) {
| array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
| });
| addParseToken('YY', function (input, array) {
| array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
| });
| // HELPERS
| function daysInYear(year) {
| return isLeapYear(year) ? 366 : 365;
| }
| function isLeapYear(year) {
| return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
| }
| // HOOKS
| utils_hooks__hooks.parseTwoDigitYear = function (input) {
| return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
| };
| // MOMENTS
| var getSetYear = makeGetSet('FullYear', false);
| function getIsLeapYear () {
| return isLeapYear(this.year());
| }
| addFormatToken('w', ['ww', 2], 'wo', 'week');
| addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
| // ALIASES
| addUnitAlias('week', 'w');
| addUnitAlias('isoWeek', 'W');
| // PARSING
| addRegexToken('w',  match1to2);
| addRegexToken('ww', match1to2, match2);
| addRegexToken('W',  match1to2);
| addRegexToken('WW', match1to2, match2);
| addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
| week[token.substr(0, 1)] = toInt(input);
| });
| // HELPERS
| // firstDayOfWeek       0 = sun, 6 = sat
| //                      the day of the week that starts the week
| //                      (usually sunday or monday)
| // firstDayOfWeekOfYear 0 = sun, 6 = sat
| //                      the first week is the week that contains the first
| //                      of this day of the week
| //                      (eg. ISO weeks use thursday (4))
| function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
| var end = firstDayOfWeekOfYear - firstDayOfWeek,
| daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
| adjustedMoment;
| if (daysToDayOfWeek > end) {
| daysToDayOfWeek -= 7;
| }
| if (daysToDayOfWeek < end - 7) {
| daysToDayOfWeek += 7;
| }
| adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
| return {
| week: Math.ceil(adjustedMoment.dayOfYear() / 7),
| year: adjustedMoment.year()
| };
| }
| // LOCALES
| function localeWeek (mom) {
| return weekOfYear(mom, this._week.dow, this._week.doy).week;
| }
| var defaultLocaleWeek = {
| dow : 0, // Sunday is the first day of the week.
| doy : 6  // The week that contains Jan 1st is the first week of the year.
| };
| function localeFirstDayOfWeek () {
| return this._week.dow;
| }
| function localeFirstDayOfYear () {
| return this._week.doy;
| }
| // MOMENTS
| function getSetWeek (input) {
| var week = this.localeData().week(this);
| return input == null ? week : this.add((input - week) * 7, 'd');
| }
| function getSetISOWeek (input) {
| var week = weekOfYear(this, 1, 4).week;
| return input == null ? week : this.add((input - week) * 7, 'd');
| }
| addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
| // ALIASES
| addUnitAlias('dayOfYear', 'DDD');
| // PARSING
| addRegexToken('DDD',  match1to3);
| addRegexToken('DDDD', match3);
| addParseToken(['DDD', 'DDDD'], function (input, array, config) {
| config._dayOfYear = toInt(input);
| });
| // HELPERS
| //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
| function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
| var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
| if (d < firstDayOfWeek) {
| d += 7;
| }
| weekday = weekday != null ? 1 * weekday : firstDayOfWeek;
| dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;
| return {
| year: dayOfYear > 0 ? year : year - 1,
| dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
| };
| }
| // MOMENTS
| function getSetDayOfYear (input) {
| var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
| return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
| }
| // Pick the first defined of two or three arguments.
| function defaults(a, b, c) {
| if (a != null) {
| return a;
| }
| if (b != null) {
| return b;
| }
| return c;
| }
| function currentDateArray(config) {
| var now = new Date();
| if (config._useUTC) {
| return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
| }
| return [now.getFullYear(), now.getMonth(), now.getDate()];
| }
| // convert an array to a date.
| // the array should mirror the parameters below
| // note: all values past the year are optional and will default to the lowest possible value.
| // [year, month, day , hour, minute, second, millisecond]
| function configFromArray (config) {
| var i, date, input = [], currentDate, yearToUse;
| if (config._d) {
| return;
| }
| currentDate = currentDateArray(config);
| //compute day of the year from weeks and weekdays
| if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
| dayOfYearFromWeekInfo(config);
| }
| //if the day of the year is set, figure out what it is
| if (config._dayOfYear) {
| yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
| if (config._dayOfYear > daysInYear(yearToUse)) {
| getParsingFlags(config)._overflowDayOfYear = true;
| }
| date = createUTCDate(yearToUse, 0, config._dayOfYear);
| config._a[MONTH] = date.getUTCMonth();
| config._a[DATE] = date.getUTCDate();
| }
| // Default to current date.
| // * if no year, month, day of month are given, default to today
| // * if day of month is given, default month and year
| // * if month is given, default only year
| // * if year is given, don't default anything
| for (i = 0; i < 3 && config._a[i] == null; ++i) {
| config._a[i] = input[i] = currentDate[i];
| }
| // Zero out whatever was not defaulted, including time
| for (; i < 7; i++) {
| config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
| }
| // Check for 24:00:00.000
| if (config._a[HOUR] === 24 &&
| config._a[MINUTE] === 0 &&
| config._a[SECOND] === 0 &&
| config._a[MILLISECOND] === 0) {
| config._nextDay = true;
| config._a[HOUR] = 0;
| }
| config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
| // Apply timezone offset from input. The actual utcOffset can be changed
| // with parseZone.
| if (config._tzm != null) {
| config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
| }
| if (config._nextDay) {
| config._a[HOUR] = 24;
| }
| }
| function dayOfYearFromWeekInfo(config) {
| var w, weekYear, week, weekday, dow, doy, temp;
| w = config._w;
| if (w.GG != null || w.W != null || w.E != null) {
| dow = 1;
| doy = 4;
| // TODO: We need to take the current isoWeekYear, but that depends on
| // how we interpret now (local, utc, fixed offset). So create
| // a now version of current config (take local/utc/offset flags, and
| // create now).
| weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
| week = defaults(w.W, 1);
| weekday = defaults(w.E, 1);
| } else {
| dow = config._locale._week.dow;
| doy = config._locale._week.doy;
| weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
| week = defaults(w.w, 1);
| if (w.d != null) {
| // weekday -- low day numbers are considered next week
| weekday = w.d;
| if (weekday < dow) {
| ++week;
| }
| } else if (w.e != null) {
| // local weekday -- counting starts from begining of week
| weekday = w.e + dow;
| } else {
| // default to begining of week
| weekday = dow;
| }
| }
| temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
| config._a[YEAR] = temp.year;
| config._dayOfYear = temp.dayOfYear;
| }
| utils_hooks__hooks.ISO_8601 = function () {};
| // date from string and format string
| function configFromStringAndFormat(config) {
| // TODO: Move this to another part of the creation flow to prevent circular deps
| if (config._f === utils_hooks__hooks.ISO_8601) {
| configFromISO(config);
| return;
| }
| config._a = [];
| getParsingFlags(config).empty = true;
| // This array is used to make a Date, either with `new Date` or `Date.UTC`
| var string = '' + config._i,
| i, parsedInput, tokens, token, skipped,
| stringLength = string.length,
| totalParsedInputLength = 0;
| tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
| for (i = 0; i < tokens.length; i++) {
| token = tokens[i];
| parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
| if (parsedInput) {
| skipped = string.substr(0, string.indexOf(parsedInput));
| if (skipped.length > 0) {
| getParsingFlags(config).unusedInput.push(skipped);
| }
| string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
| totalParsedInputLength += parsedInput.length;
| }
| // don't parse if it's not a known token
| if (formatTokenFunctions[token]) {
| if (parsedInput) {
| getParsingFlags(config).empty = false;
| }
| else {
| getParsingFlags(config).unusedTokens.push(token);
| }
| addTimeToArrayFromToken(token, parsedInput, config);
| }
| else if (config._strict && !parsedInput) {
| getParsingFlags(config).unusedTokens.push(token);
| }
| }
| // add remaining unparsed input length to the string
| getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
| if (string.length > 0) {
| getParsingFlags(config).unusedInput.push(string);
| }
| // clear _12h flag if hour is
